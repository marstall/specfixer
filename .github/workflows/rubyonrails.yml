# Optimized Ruby on Rails CI workflow
# Key optimizations:
# 1. Shared setup job to avoid duplicate Ruby/Rails environment setup
# 2. Cache test results and artifacts between jobs
# 3. Conditional job execution to skip unnecessary work
# 4. Streamlined AI analysis with better error handling

name: "Autofix (use claude to create PR with fixes failing specs)"
on:
#  push:
#    branches: [ "main" ]
#  pull_request:
#    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Branch to run tests on (default: current branch)'
        required: false
        default: ''
      force_ai_analysis:
        description: 'Force AI analysis even if tests pass'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  # Shared setup job to prepare environment once
  env-setup:
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-info.outputs.cache-key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate cache key
        id: cache-info
        run: |
          CACHE_KEY="rails-env-${{ runner.os }}-${{ hashFiles('**/Gemfile.lock') }}-${{ hashFiles('**/package-lock.json') }}"
          echo "cache-key=${CACHE_KEY}" >> $GITHUB_OUTPUT

      - name: Install Ruby and gems
        uses: ruby/setup-ruby@78c01b705fd9d5ad960d432d3a0cfa341d50e410
        with:
          ruby-version: '3.3.1'
          bundler-cache: true

      - name: Cache Rails environment
        uses: actions/cache@v3
        with:
          path: |
            vendor/bundle
            node_modules
            tmp/cache
          key: ${{ steps.cache-info.outputs.cache-key }}
          restore-keys: |
            rails-env-${{ runner.os }}-

  # Test job - now uses cached environment
  run-tests:
    runs-on: ubuntu-latest
    needs: env-setup
    env:
      RAILS_ENV: test
    outputs:
      test-result: ${{ steps.test-run.outcome }}
      test-output: ${{ steps.test-run.outputs.test-output }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Restore cached environment
        uses: actions/cache@v3
        with:
          path: |
            vendor/bundle
            node_modules
            tmp/cache
          key: ${{ needs.env-setup.outputs.cache-key }}

      - name: Install Ruby (lightweight - gems already cached)
        uses: ruby/setup-ruby@78c01b705fd9d5ad960d432d3a0cfa341d50e410
        with:
          ruby-version: '3.3.1'
          bundler-cache: true  # Let ruby/setup-ruby handle bundler cache properly

      - name: Set up database schema
        run: bin/rails db:create db:migrate

      - name: Run tests with output capture
        id: test-run
        run: |
          echo "Running tests..."
          
          # Capture test output regardless of success/failure
          set +e  # Don't exit on error
          TEST_OUTPUT=$(bin/rake 2>&1)
          TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Always capture the output
          echo "test-output<<EOF" >> $GITHUB_OUTPUT
          if [ $TEST_EXIT_CODE -eq 0 ]; then
            echo "TESTS PASSED" >> $GITHUB_OUTPUT
          else
            echo "TEST FAILURES:" >> $GITHUB_OUTPUT
          fi
          echo "$TEST_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Display the output in the log for immediate visibility
          echo "=== TEST OUTPUT ==="
          echo "$TEST_OUTPUT"
          echo "=================="
          
          # Exit with the original test exit code
          exit $TEST_EXIT_CODE

  # Run autofix workflow if tests failed OR manual trigger with force_ai_analysis
  branch-create:
    runs-on: ubuntu-latest
    needs: [env-setup, run-tests]  # Add setup dependency for better layout
    if: failure() && needs.run-tests.result == 'failure' || (github.event_name == 'workflow_dispatch' && inputs.force_ai_analysis)
    outputs:
      branch_name: ${{ steps.branch-info.outputs.branch_name }}
      failure_type: ${{ steps.branch-info.outputs.failure_type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.target_branch || github.ref }}
          token: ${{ secrets.AUTOFIX_TOKEN }}

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create branch info
        id: branch-info
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BRANCH_NAME="autofix/manual-trigger-${TIMESTAMP}"
            FAILURE_TYPE="manual"
          else
            BRANCH_NAME="autofix/ai-test-fix-${TIMESTAMP}"
            FAILURE_TYPE="test"
          fi
          
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "failure_type=${FAILURE_TYPE}" >> $GITHUB_OUTPUT

      - name: Create autofix branch
        run: |
          git checkout -b ${{ steps.branch-info.outputs.branch_name }}
          git push origin ${{ steps.branch-info.outputs.branch_name }}

  # Streamlined AI fix job - reuses environment and test output
  ai-autofix:
    runs-on: ubuntu-latest
    needs: [env-setup, run-tests, branch-create]
    if: failure() && needs.branch-create.result == 'success'
    outputs:
      has_changes: ${{ steps.ai-analysis.outputs.has_changes }}
      modified_files: ${{ steps.ai-analysis.outputs.modified_files }}
    steps:
      - name: Checkout autofix branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-create.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.AUTOFIX_TOKEN }}

      - name: Restore cached environment
        uses: actions/cache@v3
        with:
          path: |
            vendor/bundle
            node_modules
            tmp/cache
          key: ${{ needs.env-setup.outputs.cache-key }}

      - name: Install Ruby (lightweight)
        uses: ruby/setup-ruby@78c01b705fd9d5ad960d432d3a0cfa341d50e410
        with:
          ruby-version: '3.3.1'
          bundler-cache: true

      - name: Analyze commit history (optimized)
        id: commit-analysis
        run: |
          # Simplified commit analysis - get last 3 commits only
          COMMITS_JSON=$(git log HEAD~3..HEAD --format='{"sha":"%H","message":"%s","author":"%an"}' | jq -s '.')
          echo "commits_json<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Get consolidated diff for recent commits
          RECENT_DIFF=$(git diff HEAD~3..HEAD)
          echo "recent_diff<<EOF" >> $GITHUB_OUTPUT
          echo "$RECENT_DIFF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Streamlined AI fix generation
        id: ai-analysis
        uses: actions/github-script@v7
        env:
          RECENT_DIFF: ${{ steps.commit-analysis.outputs.recent_diff }}
          ERROR_OUTPUT: ${{ needs.run-tests.outputs.test-output }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-west-2
        with:
          github-token: ${{ secrets.AUTOFIX_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            const recentDiff = process.env.RECENT_DIFF || 'No recent changes';
            const errorOutput = process.env.ERROR_OUTPUT || 'No error output available';
            
            if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY) {
              console.log('ERROR: AWS credentials not found');
              core.setOutput('has_changes', 'false');
              return;
            }
            
            // Streamlined prompt focusing on key information
            const prompt = `You are a Rails developer fixing test failures in a discourse plugin.
            Where necessary and appropriate, you should consider the discourse core codebase in your fix.
            The discourse core codebase is at https://github.com/discourse/discourse. 
            Recent discourse core commits are often the cause of failing specs, so look at those.
            Also make smart searches of the discourse code base relevant to the failing spec if you think the issue might be in the discourse core.

            RECENT CHANGES:
            ${recentDiff}

            TEST FAILURES:
            ${errorOutput}

            Provide specific file fixes in this format:
            FILE: path/to/file.rb
            CONTENT:
            [complete corrected file content]

            COMMIT_MESSAGE:
            [A concise, descriptive commit message that explains what bug was fixed, written like a regular developer would write it]

            IMPORTANT RULES:
            - Only provide the actual code fixes - NO explanatory comments or documentation in the files
            - Do NOT append explanations, analysis, or comments to the end of files
            - The file content should be clean production code only
            - Keep existing code style and formatting
            - Focus only on files that need changes to fix the failing tests
            - Write a natural commit message that describes the specific bug/issue that was resolved

            Provide only the minimal necessary changes to fix the test failures.`;
            
            try {
              console.log("Starting Claude AI analysis via AWS Bedrock...");
              
              // AWS Bedrock configuration
              const region = process.env.AWS_REGION;
              const modelId = 'us.anthropic.claude-sonnet-4-20250514-v1:0';
              const bedrockUrl = `https://bedrock-runtime.${region}.amazonaws.com/model/${modelId}/invoke`;
              
              // Create AWS Signature V4 for authentication
              const crypto = require('crypto');
              
              function createSignature(method, url, headers, body, accessKey, secretKey, region, service, timestamp) {
                const algorithm = 'AWS4-HMAC-SHA256';
                const date = timestamp.toISOString().slice(0, 10).replace(/-/g, '');
                const credentialScope = `${date}/${region}/${service}/aws4_request`;
                
                // Create canonical request
                const urlObj = new URL(url);
                const canonicalUri = encodeURI(urlObj.pathname).replace(/:/g, '%3A');
                const canonicalQueryString = urlObj.search.slice(1);
                
                const canonicalHeaders = Object.keys(headers)
                  .sort()
                  .map(key => `${key.toLowerCase()}:${headers[key].trim()}`)
                  .join('\n') + '\n';
                
                const signedHeaders = Object.keys(headers)
                  .sort()
                  .map(key => key.toLowerCase())
                  .join(';');
                
                const payloadHash = crypto.createHash('sha256').update(body).digest('hex');
                
                const canonicalRequest = [
                  method,
                  canonicalUri,
                  canonicalQueryString,
                  canonicalHeaders,
                  signedHeaders,
                  payloadHash
                ].join('\n');
                
                // Create string to sign
                const canonicalRequestHash = crypto.createHash('sha256').update(canonicalRequest).digest('hex');
                const stringToSign = [
                  algorithm,
                  timestamp.toISOString().replace(/[:-]|\.\d{3}/g, ''),
                  credentialScope,
                  canonicalRequestHash
                ].join('\n');
                
                // Create signing key
                const kDate = crypto.createHmac('sha256', `AWS4${secretKey}`).update(date).digest();
                const kRegion = crypto.createHmac('sha256', kDate).update(region).digest();
                const kService = crypto.createHmac('sha256', kRegion).update(service).digest();
                const kSigning = crypto.createHmac('sha256', kService).update('aws4_request').digest();
                
                const signature = crypto.createHmac('sha256', kSigning).update(stringToSign).digest('hex');
                
                return `${algorithm} Credential=${accessKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
              }
              
              // Prepare request
              const timestamp = new Date();
              const body = JSON.stringify({
                anthropic_version: 'bedrock-2023-05-31',
                max_tokens: 2000,
                temperature: 0.1,
                system: 'You are an expert Rails developer. You are intimately familiar with the discourse core codebase and variety of techniques for creating discourse plugins. Fix test failures efficiently. Make sure to use the latest approaches to Discourse plugin development.',
                messages: [
                  {
                    role: 'user',
                    content: prompt
                  }
                ]
              });
              
              const headers = {
                'Content-Type': 'application/json',
                'X-Amz-Date': timestamp.toISOString().replace(/[:-]|\.\d{3}/g, ''),
                'Host': `bedrock-runtime.${region}.amazonaws.com`
              };
              
              const authorization = createSignature(
                'POST',
                bedrockUrl,
                headers,
                body,
                process.env.AWS_ACCESS_KEY_ID,
                process.env.AWS_SECRET_ACCESS_KEY,
                region,
                'bedrock',
                timestamp
              );
              
              headers['Authorization'] = authorization;
              
              // Make the API call
              const response = await fetch(bedrockUrl, {
                method: 'POST',
                headers: headers,
                body: body
              });
            
              if (!response.ok) {
                const errorText = await response.text();
                console.error(`AWS Bedrock API error: ${response.status} ${response.statusText}`);
                console.error(`Error details: ${errorText}`);
                throw new Error(`AWS Bedrock API failed with status ${response.status}: ${response.statusText}. Details: ${errorText}`);
              }
            
              const responseData = await response.json();
              let hasChanges = false;
              const modifiedFiles = []; // Track files we actually modify
            
              if (responseData?.content?.[0]?.text) {
                const analysis = responseData.content[0].text.trim();
                console.log("Claude AI analysis received, parsing...");
            
                // Extract commit message first
                let commitMessage = "🤖 Claude AI fixes applied";
                const commitMatch = analysis.match(/COMMIT_MESSAGE:\s*\n(.+?)(?=\n\n|$)/s);
                if (commitMatch) {
                  commitMessage = commitMatch[1].trim();
                  console.log(`📝 Generated commit message: ${commitMessage}`);
                }
            
                // Parse and apply fixes
                const sections = analysis.split('FILE:');
            
                for (const section of sections) {
                  if (!section.trim()) continue;
            
                  const lines = section.trim().split('\n');
                  const filePath = lines[0].trim();
            
                  if (!fs.existsSync(filePath)) {
                    console.log(`⚠️  File not found: ${filePath}`);
                    continue;
                  }
            
                  const contentIndex = lines.findIndex(line => line.startsWith('CONTENT:'));
                  if (contentIndex === -1) {
                    console.log(`⚠️  No CONTENT section found for: ${filePath}`);
                    continue;
                  }
            
                  // Find where CONTENT section ends (before COMMIT_MESSAGE or end of section)
                  let contentEndIndex = lines.length;
                  for (let i = contentIndex + 1; i < lines.length; i++) {
                    if (lines[i].startsWith('COMMIT_MESSAGE:')) {
                      contentEndIndex = i;
                      break;
                    }
                  }
            
                  const newContent = lines.slice(contentIndex + 1, contentEndIndex).join('\n').trim();
            
                  if (newContent && newContent.length > 10) {
                    // Read original content for comparison
                    const originalContent = fs.readFileSync(filePath, 'utf8');
                    
                    // Only modify if content is actually different
                    if (originalContent.trim() !== newContent.trim()) {
                      // Write the new content
                      fs.writeFileSync(filePath, newContent, 'utf8');
                      hasChanges = true;
                      modifiedFiles.push(filePath);
                      
                      console.log(`✅ Applied fix to ${filePath}`);
                    } else {
                      console.log(`ℹ️  No changes needed for ${filePath} (content identical)`);
                    }
                  } else {
                    console.log(`⚠️  Content too short or empty for: ${filePath}`);
                  }
                }
              } else {
                console.log('⚠️  No content found in Claude response');
              }
              
              console.log(`\n📊 Summary: ${modifiedFiles.length} files modified, hasChanges: ${hasChanges}`);
            
              // Output the list of modified files and commit message for the next step
              if (hasChanges) {
                console.log(`\n📊 Modified files: ${modifiedFiles.join(', ')}`);
                core.setOutput('modified_files', modifiedFiles.join(','));
                core.setOutput('commit_message', commitMessage);
              }
              
              core.setOutput('has_changes', hasChanges.toString());
            
            } catch (error) {
              console.error("Claude AI analysis error:", error.message);
              core.setOutput('has_changes', 'false');
              
              // CRITICAL: Fail the step when Bedrock API fails
              core.setFailed(`Claude AI analysis failed: ${error.message}`);
              throw error; // Re-throw to ensure step fails
            }

      - name: Show changes made
        if: steps.ai-analysis.outputs.has_changes == 'true'
        run: |
          echo "📊 Files modified by Claude AI:"
          echo "${{ steps.ai-analysis.outputs.modified_files }}" | tr ',' '\n' | sed 's/^/  ✅ /'
          
          echo ""
          echo "📋 Git status:"
          git status --porcelain
          
          echo ""
          echo "📝 Full diff of changes:"
          git diff

      - name: Commit and push AI fixes
        if: steps.ai-analysis.outputs.has_changes == 'true'
        run: |
          # Configure git user
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Stage only the modified files
          echo "📁 Staging modified files..."
          echo "${{ steps.ai-analysis.outputs.modified_files }}" | tr ',' '\n' | while read file; do
            if [ -n "$file" ]; then
              git add "$file"
              echo "   ✅ Staged: $file"
            fi
          done
          
          # Commit the changes using Claude's generated commit message with Discourse standard prefix and bot emoji
          git commit -m "FIX: 🤖 ${{ steps.ai-analysis.outputs.commit_message }}"
          
          # Push the changes
          git push origin ${{ needs.branch-create.outputs.branch_name }}
          
          echo "✅ Successfully committed and pushed AI fixes"

  # Commit and PR creation (unchanged but now more efficient due to upstream optimizations)
  create-pr:
    runs-on: ubuntu-latest
    needs: [env-setup, run-tests, branch-create, ai-autofix]  # Add setup for consistent layout
    if: failure() && needs.ai-autofix.result == 'success' && needs.ai-autofix.outputs.has_changes == 'true'
    steps:
      - name: Checkout autofix branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-create.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.AUTOFIX_TOKEN }}

      - name: Create PR with AI fix details
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOFIX_TOKEN }}
          script: |
            const title = `DEV: 🤖 AI Autofix: Resolve test failures`;
            
            const body = `## 🤖 AI-Generated Test Fix
            
            This PR was automatically created by Claude AI to fix failing specs in this Discourse plugin.
            
            ### 📋 Changes Made
            - **Files Modified:** ${{ needs.ai-autofix.outputs.modified_files }}
            - **Branch:** \`${{ needs.branch-create.outputs.branch_name }}\`
            - **Generated:** ${new Date().toISOString()}
            
            ### 🔍 Analysis Context
            - Analyzed recent changes and test failures
            - Applied fixes based on Discourse core codebase patterns
            - Generated clean code without explanatory comments
            
            ### 🧪 Next Steps
            1. Review the changes carefully
            2. Run tests locally to verify fixes
            3. Merge if appropriate
            
            *Generated by Claude AI via GitHub Actions*`;
            
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              head: '${{ needs.branch-create.outputs.branch_name }}',
              base: 'main',
              body: body
            });
            
            console.log(`Created optimized AI autofix PR: ${pr.html_url}`);
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['🤖 ai-generated', 'autofix', 'optimized', 'needs-review']
            });
