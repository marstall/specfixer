# Optimized Ruby on Rails CI workflow
# Key optimizations:
# 1. Shared setup job to avoid duplicate Ruby/Rails environment setup
# 2. Cache test results and artifacts between jobs
# 3. Conditional job execution to skip unnecessary work
# 4. Streamlined AI analysis with better error handling

name: "Autofix (use Claude to create PR with fixes for failing specs)"
on:
#  push:
#    branches: [ "main" ]
#  pull_request:
#    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  # Shared setup job to prepare environment once
  env-setup:
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-info.outputs.cache-key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate cache key
        id: cache-info
        run: |
          CACHE_KEY="rails-env-${{ runner.os }}-${{ hashFiles('**/Gemfile.lock') }}-${{ hashFiles('**/package-lock.json') }}"
          echo "cache-key=${CACHE_KEY}" >> $GITHUB_OUTPUT

      - name: Install Ruby and gems
        uses: ruby/setup-ruby@78c01b705fd9d5ad960d432d3a0cfa341d50e410
        with:
          ruby-version: '3.3.1'
          bundler-cache: true

      - name: Cache Rails environment
        uses: actions/cache@v3
        with:
          path: |
            vendor/bundle
            node_modules
            tmp/cache
          key: ${{ steps.cache-info.outputs.cache-key }}
          restore-keys: |
            rails-env-${{ runner.os }}-

  # Test job - now uses cached environment
  run-tests:
    runs-on: ubuntu-latest
    needs: env-setup
    env:
      RAILS_ENV: test
    outputs:
      test-result: ${{ steps.test-run.outcome }}
      test-output: ${{ steps.test-run.outputs.test-output }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Restore cached environment
        uses: actions/cache@v3
        with:
          path: |
            vendor/bundle
            node_modules
            tmp/cache
          key: ${{ needs.env-setup.outputs.cache-key }}

      - name: Install Ruby (lightweight - gems already cached)
        uses: ruby/setup-ruby@78c01b705fd9d5ad960d432d3a0cfa341d50e410
        with:
          ruby-version: '3.3.1'
          bundler-cache: true  # Let ruby/setup-ruby handle bundler cache properly

      - name: Set up database schema
        run: bin/rails db:create db:migrate

      - name: Run tests with output capture
        id: test-run
        run: |
          echo "Running tests..."
          
          # Capture test output regardless of success/failure
          set +e  # Don't exit on error
          TEST_OUTPUT=$(bin/rake 2>&1)
          TEST_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Always capture the output
          echo "test-output<<EOF" >> $GITHUB_OUTPUT
          if [ $TEST_EXIT_CODE -eq 0 ]; then
            echo "TESTS PASSED" >> $GITHUB_OUTPUT
          else
            echo "TEST FAILURES:" >> $GITHUB_OUTPUT
          fi
          echo "$TEST_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Display the output in the log for immediate visibility
          echo "=== TEST OUTPUT ==="
          echo "$TEST_OUTPUT"
          echo "=================="
          
          # Exit with the original test exit code
          exit $TEST_EXIT_CODE

  # Run autofix workflow if tests failed OR manual trigger
  branch-create:
    runs-on: ubuntu-latest
    needs: [env-setup, run-tests]  # Add setup dependency for better layout
    if: failure() && needs.run-tests.result == 'failure' || github.event_name == 'workflow_dispatch'
    outputs:
      branch_name: ${{ steps.branch-info.outputs.branch_name }}
      failure_type: ${{ steps.branch-info.outputs.failure_type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.AUTOFIX_TOKEN }}

      - name: Setup Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create branch info
        id: branch-info
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BRANCH_NAME="autofix/manual-trigger-${TIMESTAMP}"
            FAILURE_TYPE="manual"
          else
            BRANCH_NAME="autofix/ai-test-fix-${TIMESTAMP}"
            FAILURE_TYPE="test"
          fi
          
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "failure_type=${FAILURE_TYPE}" >> $GITHUB_OUTPUT

      - name: Create autofix branch
        run: |
          git checkout -b ${{ steps.branch-info.outputs.branch_name }}
          git push origin ${{ steps.branch-info.outputs.branch_name }}

  # Streamlined AI fix job - reuses environment and test output
  ai-autofix:
    runs-on: ubuntu-latest
    needs: [env-setup, run-tests, branch-create]
    if: failure() && needs.branch-create.result == 'success'
    outputs:
      has_changes: ${{ steps.ai-analysis.outputs.has_changes }}
      modified_files: ${{ steps.ai-analysis.outputs.modified_files }}
      pr_title: ${{ steps.ai-analysis.outputs.pr_title }}
      pr_analysis: ${{ steps.ai-analysis.outputs.pr_analysis }}
    steps:
      - name: Checkout autofix branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-create.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.AUTOFIX_TOKEN }}

      - name: Restore cached environment
        uses: actions/cache@v3
        with:
          path: |
            vendor/bundle
            node_modules
            tmp/cache
          key: ${{ needs.env-setup.outputs.cache-key }}

      - name: Install Ruby (lightweight)
        uses: ruby/setup-ruby@78c01b705fd9d5ad960d432d3a0cfa341d50e410
        with:
          ruby-version: '3.3.1'
          bundler-cache: true

      - name: Analyze commit history (optimized)
        id: commit-analysis
        run: |
          # Simplified commit analysis - get last 3 commits only
          COMMITS_JSON=$(git log HEAD~3..HEAD --format='{"sha":"%H","message":"%s","author":"%an"}' | jq -s '.')
          echo "commits_json<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Get consolidated diff for recent commits
          RECENT_DIFF=$(git diff HEAD~3..HEAD)
          echo "recent_diff<<EOF" >> $GITHUB_OUTPUT
          echo "$RECENT_DIFF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Streamlined AI fix generation
        id: ai-analysis
        uses: actions/github-script@v7
        env:
          RECENT_DIFF: ${{ steps.commit-analysis.outputs.recent_diff }}
          ERROR_OUTPUT: ${{ needs.run-tests.outputs.test-output }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-west-2
        with:
          github-token: ${{ secrets.AUTOFIX_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            const recentDiff = process.env.RECENT_DIFF || 'No recent changes';
            const errorOutput = process.env.ERROR_OUTPUT || 'No error output available';
            
            if (!process.env.AWS_ACCESS_KEY_ID || !process.env.AWS_SECRET_ACCESS_KEY) {
              console.log('ERROR: AWS credentials not found');
              core.setOutput('has_changes', 'false');
              return;
            }
            
            // Load prompt from external file and substitute variables
            const promptTemplate = fs.readFileSync('.github/claude-prompt.md', 'utf8');
            const prompt = promptTemplate
              .replace('{recentDiff}', recentDiff)
              .replace('{errorOutput}', errorOutput);
            
            try {
              console.log("Starting Claude AI analysis via AWS Bedrock...");
              
              // AWS Bedrock configuration
              const region = process.env.AWS_REGION;
              const modelId = 'us.anthropic.claude-sonnet-4-20250514-v1:0';
              const bedrockUrl = `https://bedrock-runtime.${region}.amazonaws.com/model/${modelId}/invoke`;
              
              // Create AWS Signature V4 for authentication
              const crypto = require('crypto');
              
              function createSignature(method, url, headers, body, accessKey, secretKey, region, service, timestamp) {
                const algorithm = 'AWS4-HMAC-SHA256';
                const date = timestamp.toISOString().slice(0, 10).replace(/-/g, '');
                const credentialScope = `${date}/${region}/${service}/aws4_request`;
                
                // Create canonical request
                const urlObj = new URL(url);
                const canonicalUri = encodeURI(urlObj.pathname).replace(/:/g, '%3A');
                const canonicalQueryString = urlObj.search.slice(1);
                
                const canonicalHeaders = Object.keys(headers)
                  .sort()
                  .map(key => `${key.toLowerCase()}:${headers[key].trim()}`)
                  .join('\n') + '\n';
                
                const signedHeaders = Object.keys(headers)
                  .sort()
                  .map(key => key.toLowerCase())
                  .join(';');
                
                const payloadHash = crypto.createHash('sha256').update(body).digest('hex');
                
                const canonicalRequest = [
                  method,
                  canonicalUri,
                  canonicalQueryString,
                  canonicalHeaders,
                  signedHeaders,
                  payloadHash
                ].join('\n');
                
                // Create string to sign
                const canonicalRequestHash = crypto.createHash('sha256').update(canonicalRequest).digest('hex');
                const stringToSign = [
                  algorithm,
                  timestamp.toISOString().replace(/[:-]|\.\d{3}/g, ''),
                  credentialScope,
                  canonicalRequestHash
                ].join('\n');
                
                // Create signing key
                const kDate = crypto.createHmac('sha256', `AWS4${secretKey}`).update(date).digest();
                const kRegion = crypto.createHmac('sha256', kDate).update(region).digest();
                const kService = crypto.createHmac('sha256', kRegion).update(service).digest();
                const kSigning = crypto.createHmac('sha256', kService).update('aws4_request').digest();
                
                const signature = crypto.createHmac('sha256', kSigning).update(stringToSign).digest('hex');
                
                return `${algorithm} Credential=${accessKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
              }
              
              // Prepare request
              const timestamp = new Date();
              const body = JSON.stringify({
                anthropic_version: 'bedrock-2023-05-31',
                max_tokens: 2000,
                temperature: 0.1,
                system: 'You are an expert Rails developer. You are intimately familiar with the discourse core codebase and variety of techniques for creating discourse plugins. Fix test failures efficiently. Make sure to use the latest approaches to Discourse plugin development.',
                messages: [
                  {
                    role: 'user',
                    content: prompt
                  }
                ]
              });
              
              const headers = {
                'Content-Type': 'application/json',
                'X-Amz-Date': timestamp.toISOString().replace(/[:-]|\.\d{3}/g, ''),
                'Host': `bedrock-runtime.${region}.amazonaws.com`
              };
              
              const authorization = createSignature(
                'POST',
                bedrockUrl,
                headers,
                body,
                process.env.AWS_ACCESS_KEY_ID,
                process.env.AWS_SECRET_ACCESS_KEY,
                region,
                'bedrock',
                timestamp
              );
              
              headers['Authorization'] = authorization;
              
              // Make the API call
              const response = await fetch(bedrockUrl, {
                method: 'POST',
                headers: headers,
                body: body
              });
            
              if (!response.ok) {
                const errorText = await response.text();
                console.error(`AWS Bedrock API error: ${response.status} ${response.statusText}`);
                console.error(`Error details: ${errorText}`);
                throw new Error(`AWS Bedrock API failed with status ${response.status}: ${response.statusText}. Details: ${errorText}`);
              }
            
              const responseData = await response.json();
              let hasChanges = false;
              const modifiedFiles = []; // Track files we actually modify
              let commitMessage = "🤖 Claude AI fixes applied"; // Declare at proper scope
              let prTitle = "AI Autofix: Resolve test failures"; // Declare at proper scope
              let prAnalysis = "Claude AI attempted to fix failing tests."; // Declare at proper scope
            
              if (responseData?.content?.[0]?.text) {
                const analysis = responseData.content[0].text.trim();
                console.log("Claude AI analysis received, parsing...");
                console.log("=== FULL CLAUDE RESPONSE ===");
                console.log(analysis);
                console.log("=== END CLAUDE RESPONSE ===");
            
                // Extract PR title and analysis with flexible parsing
                const prTitleMatch = analysis.match(/PR_TITLE:\s*\n(.+?)(?=\n\n|\nPR_ANALYSIS:|\nFILE:|$)/s);
                if (prTitleMatch) {
                  prTitle = prTitleMatch[1].trim();
                  console.log(`📋 Generated PR title: ${prTitle}`);
                } else {
                  // Fallback: try to extract from commit message or use default
                  const commitMatch = analysis.match(/COMMIT_MESSAGE:\s*\n(.+?)(?=\n\n|$)/s);
                  if (commitMatch) {
                    prTitle = commitMatch[1].trim();
                    console.log(`📋 Using commit message as PR title: ${prTitle}`);
                  } else {
                    prTitle = "AI Autofix: Resolve test failures";
                    console.log(`📋 Using default PR title: ${prTitle}`);
                  }
                }
                
                const prAnalysisMatch = analysis.match(/PR_ANALYSIS:\s*\n([\s\S]+?)(?=\nFILE:|$)/);
                if (prAnalysisMatch) {
                  prAnalysis = prAnalysisMatch[1].trim();
                  console.log(`📊 Generated PR analysis: ${prAnalysis.substring(0, 100)}...`);
                } else {
                  // Fallback: use everything before FILE: as analysis
                  const beforeFileMatch = analysis.match(/^([\s\S]+?)(?=\nFILE:|$)/);
                  if (beforeFileMatch) {
                    prAnalysis = beforeFileMatch[1].trim();
                    console.log(`📊 Using everything before FILE as PR analysis: ${prAnalysis.substring(0, 100)}...`);
                  } else {
                    prAnalysis = "Claude AI attempted to fix failing tests but no analysis was provided.";
                    console.log(`📊 Using default PR analysis`);
                  }
                }
            
                // Extract commit message
                const commitMatch = analysis.match(/COMMIT_MESSAGE:\s*\n(.+?)(?=\n\n|$)/s);
                if (commitMatch) {
                  commitMessage = commitMatch[1].trim();
                  console.log(`📝 Generated commit message: ${commitMessage}`);
                }
            
                // Parse and apply fixes
                const sections = analysis.split('FILE:');
            
                for (const section of sections) {
                  if (!section.trim()) continue;
            
                  const lines = section.trim().split('\n');
                  const filePath = lines[0].trim();
            
                  if (!fs.existsSync(filePath)) {
                    console.log(`⚠️  File not found: ${filePath}`);
                    continue;
                  }
            
                  const contentIndex = lines.findIndex(line => line.startsWith('CONTENT:'));
                  if (contentIndex === -1) {
                    console.log(`⚠️  No CONTENT section found for: ${filePath}`);
                    continue;
                  }
            
                  // Find where CONTENT section ends (before COMMIT_MESSAGE or end of section)
                  let contentEndIndex = lines.length;
                  for (let i = contentIndex + 1; i < lines.length; i++) {
                    if (lines[i].startsWith('COMMIT_MESSAGE:')) {
                      contentEndIndex = i;
                      break;
                    }
                  }
            
                  const newContent = lines.slice(contentIndex + 1, contentEndIndex).join('\n').trim();
            
                  if (newContent && newContent.length > 10) {
                    // Read original content for comparison
                    const originalContent = fs.readFileSync(filePath, 'utf8');
                    
                    // Only modify if content is actually different
                    if (originalContent.trim() !== newContent.trim()) {
                      // Write the new content
                      fs.writeFileSync(filePath, newContent, 'utf8');
                      hasChanges = true;
                      modifiedFiles.push(filePath);
                      
                      console.log(`✅ Applied fix to ${filePath}`);
                    } else {
                      console.log(`ℹ️  No changes needed for ${filePath} (content identical)`);
                    }
                  } else {
                    console.log(`⚠️  Content too short or empty for: ${filePath}`);
                  }
                }
              } else {
                console.log('⚠️  No content found in Claude response');
              }
              
              console.log(`\n📊 Summary: ${modifiedFiles.length} files modified, hasChanges: ${hasChanges}`);
            
              // Output the list of modified files and commit message for the next step
              if (hasChanges) {
                console.log(`\n📊 Modified files: ${modifiedFiles.join(', ')}`);
                core.setOutput('modified_files', modifiedFiles.join(','));
              } else {
                console.log(`\n📊 No files were modified by Claude AI`);
                core.setOutput('modified_files', 'No files modified');
              }
              
              // Always output commit message (even if no changes, for debugging)
              // Write commit message to file to avoid GitHub Actions variable substitution issues
              const commitMessageWithPrefix = `FIX: 🤖 ${commitMessage.replace(/\n/g, ' ').replace(/\r/g, '').trim()}`;
              fs.writeFileSync('/tmp/commit_message.txt', commitMessageWithPrefix, 'utf8');
              console.log(`📝 Commit message written to file: ${commitMessageWithPrefix}`);
              
              // Output PR title and analysis for PR creation (with fallbacks)
              const finalPrTitle = prTitle || "Resolve test failures";
              const finalPrAnalysis = prAnalysis || "Claude AI attempted to fix failing tests but no detailed analysis was provided.";
              
              console.log(`🎯 Final PR title: "${finalPrTitle}"`);
              console.log(`🎯 Final PR analysis length: ${finalPrAnalysis.length} characters`);
              
              core.setOutput('pr_title', finalPrTitle);
              core.setOutput('pr_analysis', finalPrAnalysis);
              core.setOutput('has_changes', hasChanges.toString());
            
            } catch (error) {
              console.error("Claude AI analysis error:", error.message);
              core.setOutput('has_changes', 'false');
              
              // CRITICAL: Fail the step when Bedrock API fails
              core.setFailed(`Claude AI analysis failed: ${error.message}`);
              throw error; // Re-throw to ensure step fails
            }

      - name: Show changes made
        if: steps.ai-analysis.outputs.has_changes == 'true'
        run: |
          echo "📊 Files modified by Claude AI:"
          echo "${{ steps.ai-analysis.outputs.modified_files }}" | tr ',' '\n' | sed 's/^/  ✅ /'
          
          echo ""
          echo "📋 Git status:"
          git status --porcelain
          
          echo ""
          echo "📝 Full diff of changes:"
          git diff

      - name: Commit and push AI fixes
        if: steps.ai-analysis.outputs.has_changes == 'true'
        run: |
          # Configure git user
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Stage only the modified files
          echo "📁 Staging modified files..."
          echo "${{ steps.ai-analysis.outputs.modified_files }}" | tr ',' '\n' | while read file; do
            if [ -n "$file" ]; then
              git add "$file"
              echo "   ✅ Staged: $file"
            fi
          done
          
          # Commit the changes using Claude's generated commit message from file
          # This avoids GitHub Actions variable substitution issues with special characters
          git commit -F /tmp/commit_message.txt
          
          # Push the changes
          git push origin ${{ needs.branch-create.outputs.branch_name }}
          
          echo "✅ Successfully committed and pushed AI fixes"

  # Commit and PR creation (unchanged but now more efficient due to upstream optimizations)
  create-pr:
    runs-on: ubuntu-latest
    needs: [env-setup, run-tests, branch-create, ai-autofix]  # Add setup for consistent layout
    if: failure() && needs.ai-autofix.result == 'success' && needs.ai-autofix.outputs.has_changes == 'true'
    steps:
      - name: Checkout autofix branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-create.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.AUTOFIX_TOKEN }}

      - name: Create PR with AI fix details
        uses: actions/github-script@v7
        env:
          PR_TITLE: ${{ needs.ai-autofix.outputs.pr_title }}
          PR_ANALYSIS: ${{ needs.ai-autofix.outputs.pr_analysis }}
          MODIFIED_FILES: ${{ needs.ai-autofix.outputs.modified_files }}
          BRANCH_NAME: ${{ needs.branch-create.outputs.branch_name }}
        with:
          github-token: ${{ secrets.AUTOFIX_TOKEN }}
          script: |
            const prTitle = process.env.PR_TITLE || 'Resolve test failures';
            const prAnalysis = process.env.PR_ANALYSIS || 'Claude AI attempted to fix failing tests.';
            const modifiedFiles = process.env.MODIFIED_FILES || 'No files modified';
            const branchName = process.env.BRANCH_NAME || 'autofix-branch';
            
            const title = `DEV: 🤖 ${prTitle}`;
            
            const timestamp = new Date().toISOString();
            const body = `## 🤖 AI-Generated Test Fix
            
            This PR was automatically created by Claude AI to fix failing specs in this Discourse plugin.
            
            ### 🧠 Claude's Analysis
            
            ${prAnalysis}
            
            ### 📋 Changes Made
            - **Files Modified:** ${modifiedFiles}
            - **Branch:** \`${branchName}\`
            - **Generated:** ${timestamp}
            ### 🧪 Next Steps
            1. Review Claude's analysis and reasoning above
            2. Examine the proposed code changes
            3. Run tests locally to verify the fix works
            4. Refine the solution if needed
            5. Merge when satisfied with the fix
            
            *Generated by Claude AI via GitHub Actions*`;
            
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              head: '${{ needs.branch-create.outputs.branch_name }}',
              base: 'main',
              body: body
            });
            
            console.log(`Created optimized AI autofix PR: ${pr.html_url}`);
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['🤖 autofix']
            });
            
            // Store PR number for verification step
            core.setOutput('pr_number', pr.number);

  # Verify the fix and retry up to 5 times if needed
  verify-fix-with-retry:
    runs-on: ubuntu-latest
    needs: [env-setup, run-tests, branch-create, ai-autofix, create-pr]
    if: failure() && needs.create-pr.result == 'success'
    steps:
      - name: Checkout autofix branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-create.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.AUTOFIX_TOKEN }}

      - name: Restore cached environment
        uses: actions/cache/restore@v4
        with:
          path: |
            vendor/bundle
            node_modules
            tmp/cache
          key: ${{ needs.env-setup.outputs.cache-key }}
          restore-keys: |
            rails-${{ runner.os }}-${{ hashFiles('**/Gemfile.lock') }}-
            rails-${{ runner.os }}-

      - name: Install Ruby (lightweight)
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: .ruby-version
          bundler-cache: false  # Use cached gems

      - name: Retry loop - AI fix and verify up to 5 times
        uses: actions/github-script@v7
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-west-2
          PR_NUMBER: ${{ needs.create-pr.outputs.pr_number }}
          BRANCH_NAME: ${{ needs.branch-create.outputs.branch_name }}
        with:
          github-token: ${{ secrets.AUTOFIX_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const crypto = require('crypto');
            
            const maxAttempts = 5;
            let attempt = 1;
            let finalStatus = 'failed';
            let lastTestOutput = '';
            
            // AWS Bedrock helper function
            function createSignature(method, url, headers, body, accessKey, secretKey, region, service, timestamp) {
              const algorithm = 'AWS4-HMAC-SHA256';
              const date = timestamp.toISOString().slice(0, 10).replace(/-/g, '');
              const credentialScope = `${date}/${region}/${service}/aws4_request`;
              
              const urlObj = new URL(url);
              const canonicalUri = encodeURI(urlObj.pathname).replace(/:/g, '%3A');
              const canonicalQueryString = urlObj.search.slice(1);
              
              const canonicalHeaders = Object.keys(headers)
                .sort()
                .map(key => `${key.toLowerCase()}:${headers[key].trim()}`)
                .join('\n') + '\n';
              
              const signedHeaders = Object.keys(headers)
                .sort()
                .map(key => key.toLowerCase())
                .join(';');
              
              const payloadHash = crypto.createHash('sha256').update(body).digest('hex');
              
              const canonicalRequest = [
                method, canonicalUri, canonicalQueryString,
                canonicalHeaders, signedHeaders, payloadHash
              ].join('\n');
              
              const canonicalRequestHash = crypto.createHash('sha256').update(canonicalRequest).digest('hex');
              const stringToSign = [
                algorithm,
                timestamp.toISOString().replace(/[:-]|\.\d{3}/g, ''),
                credentialScope, canonicalRequestHash
              ].join('\n');
              
              const kDate = crypto.createHmac('sha256', `AWS4${secretKey}`).update(date).digest();
              const kRegion = crypto.createHmac('sha256', kDate).update(region).digest();
              const kService = crypto.createHmac('sha256', kRegion).update(service).digest();
              const kSigning = crypto.createHmac('sha256', kService).update('aws4_request').digest();
              
              const signature = crypto.createHmac('sha256', kSigning).update(stringToSign).digest('hex');
              return `${algorithm} Credential=${accessKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
            }
            
            // Function to run tests and capture output
            function runTests() {
              try {
                const output = execSync('bundle exec rspec --format documentation --color 2>&1', { encoding: 'utf8' });
                return { success: true, output };
              } catch (error) {
                return { success: false, output: error.stdout || error.message };
              }
            }
            
            // Function to call Claude AI for fixes
            async function callClaudeAI(testOutput, attemptNum) {
              const region = process.env.AWS_REGION;
              const modelId = 'us.anthropic.claude-sonnet-4-20250514-v1:0';
              const bedrockUrl = `https://bedrock-runtime.${region}.amazonaws.com/model/${modelId}/invoke`;
              
              // Load prompt template
              const promptTemplate = fs.readFileSync('.github/claude-prompt.md', 'utf8');
              const prompt = promptTemplate
                .replace('{recentDiff}', 'Previous attempt failed')
                .replace('{errorOutput}', testOutput);
              
              const timestamp = new Date();
              const body = JSON.stringify({
                anthropic_version: 'bedrock-2023-05-31',
                max_tokens: 2000,
                temperature: 0.1,
                system: `You are an expert Rails developer. This is attempt ${attemptNum} of ${maxAttempts} to fix failing tests. ${attemptNum > 1 ? 'Previous attempts failed - try a different approach.' : ''}`,
                messages: [{ role: 'user', content: prompt }]
              });
              
              const headers = {
                'Content-Type': 'application/json',
                'X-Amz-Date': timestamp.toISOString().replace(/[:-]|\.\d{3}/g, ''),
                'Host': `bedrock-runtime.${region}.amazonaws.com`
              };
              
              const authorization = createSignature(
                'POST', bedrockUrl, headers, body,
                process.env.AWS_ACCESS_KEY_ID, process.env.AWS_SECRET_ACCESS_KEY,
                region, 'bedrock', timestamp
              );
              headers['Authorization'] = authorization;
              
              const response = await fetch(bedrockUrl, {
                method: 'POST', headers, body
              });
              
              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`AWS Bedrock API failed: ${response.status} - ${errorText}`);
              }
              
              return await response.json();
            }
            
            // Initial test run to check current status
            console.log('🧪 Running initial test verification...');
            let testResult = runTests();
            
            if (testResult.success) {
              finalStatus = 'success';
              console.log('✅ Tests are already passing!');
            } else {
              lastTestOutput = testResult.output;
              console.log('❌ Tests are failing, starting retry loop...');
            }
            
            // Main retry loop
            while (attempt <= maxAttempts && finalStatus !== 'success') {
              console.log(`\n🔄 Starting attempt ${attempt}/${maxAttempts}`);
              
              try {
                // Comment on PR with current attempt
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.PR_NUMBER,
                  body: `## 🔄 Retry Attempt ${attempt}/${maxAttempts}\n\n**Status:** Analyzing test failures and generating new fixes...\n\n*Started at: ${new Date().toISOString()}*`
                });
                
                // Call Claude AI for fixes
                console.log('🤖 Calling Claude AI for fixes...');
                const response = await callClaudeAI(lastTestOutput, attempt);
                
                if (!response?.content?.[0]?.text) {
                  throw new Error('No content in Claude response');
                }
                
                const analysis = response.content[0].text.trim();
                console.log('📝 Claude analysis received');
                
                // Apply fixes
                let hasChanges = false;
                const modifiedFiles = [];
                const sections = analysis.split('FILE:');
                
                for (const section of sections) {
                  if (!section.trim()) continue;
                  
                  const lines = section.trim().split('\n');
                  const filePath = lines[0].trim();
                  
                  if (!fs.existsSync(filePath)) continue;
                  
                  const contentIndex = lines.findIndex(line => line.startsWith('CONTENT:'));
                  if (contentIndex === -1) continue;
                  
                  let contentEndIndex = lines.length;
                  for (let i = contentIndex + 1; i < lines.length; i++) {
                    if (lines[i].startsWith('COMMIT_MESSAGE:')) {
                      contentEndIndex = i;
                      break;
                    }
                  }
                  
                  const newContent = lines.slice(contentIndex + 1, contentEndIndex).join('\n').trim();
                  
                  if (newContent && newContent.length > 10) {
                    const originalContent = fs.readFileSync(filePath, 'utf8');
                    if (originalContent.trim() !== newContent.trim()) {
                      fs.writeFileSync(filePath, newContent, 'utf8');
                      hasChanges = true;
                      modifiedFiles.push(filePath);
                      console.log(`✅ Applied fix to ${filePath}`);
                    }
                  }
                }
                
                if (hasChanges) {
                  // Commit changes
                  execSync('git config user.name "github-actions[bot]"');
                  execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
                  
                  modifiedFiles.forEach(file => {
                    execSync(`git add "${file}"`);
                  });
                  
                  const commitMessage = `FIX: 🤖 Retry attempt ${attempt}/${maxAttempts} - AI autofix`;
                  execSync(`git commit -m "${commitMessage}"`);
                  execSync(`git push origin ${process.env.BRANCH_NAME}`);
                  
                  console.log('✅ Changes committed and pushed');
                }
                
                // Test the fix
                console.log('🧪 Running tests to verify fix...');
                testResult = runTests();
                
                // Comment with results
                const analysisPreview = analysis.substring(0, 500) + (analysis.length > 500 ? '...' : '');
                const statusIcon = testResult.success ? '✅' : '❌';
                const statusText = testResult.success ? 'PASSED' : 'FAILED';
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.PR_NUMBER,
                  body: `## ${statusIcon} Attempt ${attempt}/${maxAttempts} Results\n\n**Status:** ${statusText}\n\n### 🧠 Claude's Thinking\n\`\`\`\n${analysisPreview}\n\`\`\`\n\n### 📁 Files Modified\n${modifiedFiles.length > 0 ? modifiedFiles.map(f => `- ${f}`).join('\n') : 'No files modified'}\n\n### 🧪 Test Results\n\`\`\`\n${testResult.output.substring(0, 1000)}${testResult.output.length > 1000 ? '\n... (truncated)' : ''}\n\`\`\`\n\n---\n*Completed at: ${new Date().toISOString()}*`
                });
                
                if (testResult.success) {
                  finalStatus = 'success';
                  console.log('🎉 Tests passed! Fix successful.');
                  break;
                } else {
                  lastTestOutput = testResult.output;
                  console.log(`❌ Tests still failing. Attempt ${attempt} failed.`);
                }
                
              } catch (error) {
                console.error(`❌ Attempt ${attempt} failed:`, error.message);
                lastTestOutput = error.message;
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.PR_NUMBER,
                  body: `## ❌ Attempt ${attempt}/${maxAttempts} Failed\n\n**Error:** ${error.message}\n\n*Failed at: ${new Date().toISOString()}*`
                });
              }
              
              attempt++;
            }
            
            // Final status update
            const finalIcon = finalStatus === 'success' ? '✅' : '❌';
            const finalMessage = finalStatus === 'success' 
              ? `🎉 **SUCCESS!** Tests are now passing after ${attempt - 1} attempts.`
              : `❌ **FAILED** after ${maxAttempts} attempts. Manual intervention may be required.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: process.env.PR_NUMBER,
              body: `## 🏁 Final Results\n\n${finalMessage}\n\n**Total Attempts:** ${attempt - 1}/${maxAttempts}\n**Final Status:** ${finalIcon} ${finalStatus.toUpperCase()}\n\n---\n*Autofix retry process completed at: ${new Date().toISOString()}*`
            });
            
            // Update PR labels
            const labelsToAdd = finalStatus === 'success' ? ['✅ fix-verified'] : ['❌ fix-needs-work'];
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: process.env.PR_NUMBER,
              labels: labelsToAdd
            });
            
            if (finalStatus !== 'success') {
              core.setFailed(`Tests still failing after ${maxAttempts} retry attempts`);
            }
